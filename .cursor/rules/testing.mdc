---
description: Testing conventions for writing concise, comprehensive tests
globs: tests/**/*.test.ts
alwaysApply: false
---

# Testing Conventions

## Combine Similar Tests

Use `it.each` to combine tests that follow the same pattern. Every case must still be covered.

```typescript
// BAD: repetitive tests with identical structure
it('returns 400 when name is missing', async () => { ... })
it('returns 400 when category is missing', async () => { ... })
it('returns 400 when quantity is missing', async () => { ... })

// GOOD: combined with it.each, all cases still covered
it.each([
  ['name', { category: 'equipment', quantity: 1, status: 'pending' }],
  ['category', { name: 'Tent', quantity: 1, status: 'pending' }],
  ['quantity', { name: 'Tent', category: 'equipment', status: 'pending' }],
])('returns 400 when %s is missing', async (_field, payload) => {
  const response = await app.inject({ method: 'POST', url, payload })
  expect(response.statusCode).toBe(400)
})
```

## Avoid Redundant Tests

Do not write a separate test if its assertions are already fully covered by another test. For example, a "returns correct structure" test is redundant if the main happy-path test already asserts every property.

## When NOT to Combine

Keep tests separate when:
- They have meaningfully different setup or mock configurations
- Combining would make the test name unclear or the failure message unhelpful
- The logic being tested is fundamentally different (e.g., happy path vs error path)
